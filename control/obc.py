# obc.py - optimization based control module
#
# RMM, 11 Feb 2021
#

"""The "mod:`~control.obc` module provides support for optimization-based
controllers for nonlinear systems with state and input constraints.

"""

import numpy as np
import scipy as sp
import scipy.optimize as opt
import control as ct
import warnings

from .timeresp import _process_time_response

class ModelPredictiveController():
    """The :class:`ModelPredictiveController` class is a front end for computing
    an optimal control input for a nonilinear system with a user-defined cost
    function and state and input constraints.

    """
    def __init__(
            self, sys, time, integral_cost, trajectory_constraints=[],
            terminal_cost=None, terminal_constraints=[]):

        self.system = sys
        self.time_vector = time
        self.integral_cost = integral_cost
        self.trajectory_constraints = trajectory_constraints
        self.terminal_cost = terminal_cost
        self.terminal_constraints = terminal_constraints

        #
        # The approach that we use here is to set up an optimization over the
        # inputs at each point in time, using the integral and terminal costs
        # as well as the trajectory and terminal constraints.  The main work
        # of this method is to create the optimization problem that can be
        # solved with scipy.optimize.minimize().
        #

        # Gather together all of the constraints
        constraint_lb, constraint_ub = [], []
        for time in self.time_vector:
            for constraint in self.trajectory_constraints:
                type, fun, lb, ub = constraint
                constraint_lb.append(lb)
                constraint_ub.append(ub)
        for constraint in self.terminal_constraints:
            type, fun, lb, ub = constraint
            constraint_lb.append(lb)
            constraint_ub.append(ub)

        # Turn constraint vectors into 1D arrays
        self.constraint_lb = np.hstack(constraint_lb)
        self.constraint_ub = np.hstack(constraint_ub)

        # Create the new constraint
        self.constraints = sp.optimize.NonlinearConstraint(
            self.constraint_function, self.constraint_lb, self.constraint_ub)
        
        # Initial guess
        self.initial_guess = np.zeros(
            self.system.ninputs * self.time_vector.size)

    #
    # Cost function
    #
    # Given the input U = [u[0], ... u[N]], we need to compute the cost of
    # the trajectory generated by that input.  This means we have to
    # simulate the system to get the state trajectory X = [x[0], ...,
    # x[N]] and then compute the cost at each point:
    #
    #   Cost = sum_k integral_cost(x[k], u[k]) + terminal_cost(x[N], u[N])
    #
    def cost_function(self, inputs):
        # Reshape the input vector
        inputs = inputs.reshape(
            (self.system.ninputs, self.time_vector.size))
        
        # Simulate the system to get the state
        _, _, states = ct.input_output_response(
            self.system, self.time_vector, inputs, self.x, return_x=True)
        
        # Trajectory cost
        # TODO: vectorize
        cost = 0
        for i, time in enumerate(self.time_vector):
            cost += self.integral_cost(states[:,i], inputs[:,i]) 
            
        # Terminal cost
        if self.terminal_cost is not None:
            cost += self.terminal_cost(states[:,-1], inputs[:,-1])
            
        # Return the total cost for this input sequence
        return cost

    #
    # Constraints
    #
    # We are given the constraints along the trajectory and the terminal
    # constraints, which each take inputs [x, u] and evaluate the
    # constraint.  How we handle these depends on the type of constraint:
    #
    # We have stored the form of the constraint at a single point, but we
    # now need to extend this to apply to each point in the trajectory.
    # This means that we need to create N constraints, each of which holds
    # at a specific point in time, and implements the original constraint.
    #
    # To do this, we basically create a function that simulates the system
    # dynamics and returns a vector of values corresponding to the value
    # of the function at each time.  We also replicate the upper and lower
    # bounds for each point in time.
    #
    
    # Define a function to evaluate all of the constraints
    def constraint_function(self, inputs):
        # Reshape the input vector
        inputs = inputs.reshape(
            (self.system.ninputs, self.time_vector.size))
            
        # Simulate the system to get the state
        _, _, states = ct.input_output_response(
            self.system, self.time_vector, inputs, self.x, return_x=True)

        value = []
        for i, time in enumerate(self.time_vector):
            for constraint in self.trajectory_constraints:
                type, fun, lb, ub = constraint
                if type == opt.LinearConstraint:
                    value.append(
                        np.dot(fun, np.hstack([states[:,i], inputs[:,i]])))
                else:
                    raise TypeError("unknown constraint type %s" %
                                    constraint[0])

        for constraint in self.terminal_constraints:
            type, fun, lb, ub = constraint
            if type == opt.LinearConstraint:
                value.append(
                    np.dot(fun, np.hstack([states[:,i], inputs[:,i]])))
            else:
                raise TypeError("unknown constraint type %s" %
                                constraint[0])

        # Return the value of the constraint function
        return np.hstack(value)

    def __call__(self, x):
        """Compute the optimal input at state x"""
        # Store the starting point
        # TODO: call compute_trajectory?
        self.x = x
        
        # Call ScipPy optimizer
        res = sp.optimize.minimize(
            self.cost_function, self.initial_guess,
            constraints=self.constraints)

        # Return the result
        if res.success:
            return res.x[0]
        else:
            warnings.warn(res.message)
            return None

    def compute_trajectory(
            self, x, squeeze=None, transpose=None, return_x=None):
        """Compute the optimal input at state x"""
        # Store the starting point
        self.x = x
        
        # Call ScipPy optimizer
        res = sp.optimize.minimize(
            self.cost_function, self.initial_guess,
            constraints=self.constraints)

        # See if we got an answer
        if not res.success:
            warnings.warn(res.message)
            return None

        # Reshape the input vector
        inputs = res.x.reshape(
            (self.system.ninputs, self.time_vector.size))
            
        return _process_time_response(
            self.system, self.time_vector, inputs, None,
            transpose=transpose, return_x=return_x, squeeze=squeeze)

def state_poly_constraint(sys, polytope):
    """Create state constraint from polytope"""
    # TODO: make sure the system and constraints are compatible

    # Return a linear constraint object based on the polynomial
    return (opt.LinearConstraint,
            np.hstack(
                [polytope.A, np.zeros((polytope.A.shape[0], sys.ninputs))]),
            np.full(polytope.A.shape[0], -np.inf), polytope.b)


def input_poly_constraint(sys, polytope):
    """Create input constraint from polytope"""
    # TODO: make sure the system and constraints are compatible

    # Return a linear constraint object based on the polynomial
    return (opt.LinearConstraint,
            np.hstack(
                [np.zeros((polytope.A.shape[0], sys.nstates)), polytope.A]),
            np.full(polytope.A.shape[0], -np.inf), polytope.b)


def quadratic_cost(sys, Q, R):
    """Create quadratic cost function"""
    return lambda x, u: x @ Q @ x + u @ R @ u
